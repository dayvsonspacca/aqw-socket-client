<?php

declare(strict_types=1);

namespace AqwSocketClient;

use AqwSocketClient\Interfaces\EventInterface;
use AqwSocketClient\Messages\{DelimitedMessage, JsonMessage, XmlMessage};
use React\Promise\Deferred;
use React\Socket\{ConnectionInterface, Connector};
use RuntimeException;

/**
 * The main client class responsible for establishing and maintaining the
 * socket connection to the AQW server.
 *
 * It manages the I/O loop, processes incoming raw messages through interpreters,
 * and sends commands generated by translators back to the server.
 */
class Client
{
    /**
     * @var ConnectionInterface|null The active socket connection instance, or null if disconnected.
     */
    private ?ConnectionInterface $connection = null;
    private string $buffer = '';

    /**
     * @param Server $server The configuration object describing the target AQW server (hostname, port, name).
     * @param Configuration $configuration The application configuration, including interpreters and translators.
     */
    public function __construct(
        private readonly Server $server,
        private readonly Configuration $configuration
    ) {}

    /**
     * Attempts to establish an asynchronous TCP connection to the configured AQW server.
     *
     * This method initializes the connection, sets up handlers for data and connection
     * lifecycle events, and returns a promise for tracking connection status.
     *
     * @return \React\Promise\PromiseInterface A promise that resolves upon successful connection
     * or rejects upon failure.
     */
    public function connect()
    {
        $connector = new Connector();
        $deferred  = new Deferred();

        $target = "tcp://{$this->server->hostname}:{$this->server->port}";
        echo "Attempting to connect to {$this->server->name} at {$target}" . PHP_EOL;

        $connector->connect($target)
            ->then(
                function (ConnectionInterface $connection) use ($deferred) {
                    echo "Connection to {$this->server->name} established." . PHP_EOL;

                    $this->connection = $connection;
                    $this->setupConnectionHandlers($connection);
                },
                fn(\Throwable $e) => $deferred->reject($e)
            );

        return $deferred->promise();
    }

    /**
     * Sets up event listeners for the established socket connection.
     *
     * Registers handlers for 'close' (connection termination) and 'data' (incoming server messages).
     *
     * @param ConnectionInterface $connection The active connection instance.
     * @return void
     */
    private function setupConnectionHandlers(ConnectionInterface $connection): void
    {
        $connection->on('close', function () {
            echo "Connection to {$this->server->name} closed." . PHP_EOL;
            $this->connection = null;
            $this->buffer = '';
        });

        $connection->on('data', function (string $data) {
            $this->buffer .= $data;
            $this->processBuffer();
        });
    }

    private function processBuffer()
    {
        while (true) {
            $delimiterPosition = strpos($this->buffer, "\x00");

            if ($delimiterPosition === false) {
                break;
            }

            $rawMessage = substr($this->buffer, 0, $delimiterPosition + 1);
            $this->buffer = substr($this->buffer, $delimiterPosition + 1);

            $this->processRawMessage($rawMessage);
            break;
        }
    }

    private function processRawMessage(string $rawMessage): void
    {
        $events = $this->handleMessage($rawMessage);
        
        $commands = [];
        foreach ($events as $event) {
            foreach ($this->configuration->translators as $translator) {
                $commands[] = $translator->translate($event);
            }

            foreach ($this->configuration->listeners as $listener) {
                $listener->listen($event);
            }
        }

        $commands = array_filter($commands, fn($command) => $command);
        foreach ($commands as $command) {
            $this->sendPacket($command->pack());
        }
    }

    /**
     * Writes a pre-packaged {@see AqwSocketClient\Packet} object to the active socket connection.
     *
     * @param Packet $packet The packet ready to be sent.
     * @return void
     * @throws RuntimeException If called when the connection is not active.
     */
    private function sendPacket(Packet $packet): void
    {
        if ($this->connection === null) {
            throw new RuntimeException('Cannot send packet, connection is not open.');
        }

        $this->connection->write($packet->unpacketify());
    }

    /**
     * Processes raw incoming data from the server.
     *
     * 1. Sanitizes the data (removes null terminators).
     * 2. Attempts to parse the data into all known message types (XML, Delimited, JSON).
     * 3. Passes successful message objects through all configured interpreters to generate events.
     *
     * @param string $data The raw string data received from the socket.
     * @return EventInterface[] An array of events generated by all interpreters.
     */
    private function handleMessage(string $data): array
    {
        $data = str_replace(["\x00"], '', $data);

        if ($this->configuration->logMessages) {
            echo $data . PHP_EOL;
        }

        $messages = [XmlMessage::fromString($data), DelimitedMessage::fromString($data), JsonMessage::fromString($data)];
        $messages = array_filter($messages, fn($message) => $message);

        $events = [];
        foreach ($this->configuration->interpreters as $interpreter) {
            foreach ($messages as $message) {
                $events = array_merge($interpreter->interpret($message), $events);
            }
        }

        return $events;
    }
}
